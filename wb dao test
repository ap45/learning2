import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import java.lang.reflect.Constructor;
import java.sql.Types;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

class WorkbenchDaoTest {

    @Mock
    private JdbcTemplate jdbcTemplate;

    @Mock
    private RowMapperFactory rowMapperFactory;

    @InjectMocks
    private WorkbenchDao<Object> workbenchDao;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.initMocks(this);
        workbenchDao = new WorkbenchDao<>();
    }

    @Test
    void testGetWorkbenchData() {
        // Arrange
        String gridId = "testGridId";
        String query = "SELECT * FROM test_table WHERE id = :param0";
        List<Object> fieldValues = Arrays.asList(123);

        // Mocking
        NamedParameterJdbcTemplate namedParameterJdbcTemplateMock = mock(NamedParameterJdbcTemplate.class);
        when(jdbcTemplate.queryForObject(any(), any(), any(RowMapper.class))).thenReturn(new Object());
        when(rowMapperFactory.getRowMapper(gridId)).thenReturn(mock(RowMapper.class));
        when(namedParameterJdbcTemplateMock.query(anyString(), any(), any(RowMapper.class)))
                .thenReturn(Arrays.asList(new Object()));

        // Inject mock into the class
        workbenchDao.namedParameterJdbcTemplate = namedParameterJdbcTemplateMock;

        // Act
        List<Object> result = workbenchDao.getWorkbenchData(gridId, query, fieldValues);

        // Assert
        assertEquals(1, result.size()); // Adjust based on the actual behavior
        // Verify interactions with mocks
        // Note: Adjust the verification based on your actual method calls
        verify(namedParameterJdbcTemplateMock, times(1)).query(anyString(), any(), any(RowMapper.class));
    }

    @Test
    void testCustomSqlParameterSource() throws Exception {
        // Arrange
        List<Object> fieldValues = Arrays.asList("value1", 42);

        // Use reflection to access the private constructor
        Constructor<WorkbenchDao.CustomSqlParameterSource> constructor =
                WorkbenchDao.CustomSqlParameterSource.class.getDeclaredConstructor(List.class);
        constructor.setAccessible(true);

        // Act
        WorkbenchDao.CustomSqlParameterSource customSqlParameterSource = constructor.newInstance(fieldValues);

        // Assert
        assertEquals(true, customSqlParameterSource.hasValue("param0"));
        assertEquals("value1", customSqlParameterSource.getValue("param0"));
        assertEquals(Types.NVARCHAR, customSqlParameterSource.getSqlType("param0"));
        // Add more assertions based on your actual mapping and cases
    }

    @Test
    void testCustomSqlParameterSourceEmptyValues() throws Exception {
        // Arrange
        List<Object> fieldValues = Collections.emptyList();

        // Use reflection to access the private constructor
        Constructor<WorkbenchDao.CustomSqlParameterSource> constructor =
                WorkbenchDao.CustomSqlParameterSource.class.getDeclaredConstructor(List.class);
        constructor.setAccessible(true);

        // Act
        WorkbenchDao.CustomSqlParameterSource customSqlParameterSource = constructor.newInstance(fieldValues);

        // Assert
        assertFalse(customSqlParameterSource.hasValue("param0"));
        assertThrows(IllegalArgumentException.class, () -> customSqlParameterSource.getValue("param0"));
        assertEquals(SqlTypeValue.TYPE_UNKNOWN, customSqlParameterSource.getSqlType("param0"));
    }
}
